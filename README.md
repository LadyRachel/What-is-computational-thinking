# What-is-computational-thinking
Rachel Gabe Jake Seaside chat 276
A. A public GitHub repo for the chat. 

B. A README.md file in the repo that includes

A list of learning outcomes for the activity. These outcomes do not need to be complicated, given that this is a short and simple activity you are leading. See the TLC guide on Learning Outcomes for more background on what makes a good outcome.
A short explanation for why you are teaching the topic you chose.
Key information on the topic that you will present
An answer to the question: What will it look like when students master these learning outcomes
C. A short activity for students to do in class that helps them learn the topic. This can be in the GitHub repo or separate, depending on what kind of activity you run. Creativity encouraged!

Before or within a day after you run your Seaside Chat, please submit the your GitHub repo through Gradescope by following the link below.

A. Learning Outcomes
By the end of this short activity, students will be able to:
1. Define computational thinking as a clear, stepwise, repeatable approach to issues
2. Explain the difference between computational thinking and coding
3. Recognize when computational thinking can improve their own academic or research workflows.

B. Why we are covering this Topic
Computational thinking is useful far beyond computer science.
Students regularly face messy, ambiguous problems. In labs, research, writing, or daily life, we can feel stuck because we don’t know how to structure our thinking.
It empowers us to: plan better experiments, structure data collection, design reproducible workflows, reduce errors, and (ultimetely) save time

C. Key Information to Present
What computational thinking IS:
-Explicit reasoning
-Clear (unambiguous assumptions)
-Repeatable 
-Testable (can debug steps and give it to others to reproduce)
What it is **NOT**
Not a computer “thinking” (this doesn't exist!!)
Not magic~
Definitely not limited by inputs and assumptions
The 4 Core Steps
Decompose, which is to break big problems into small pieces
Recognize patterns
Abstraction, focus only on what matters
Algorithmic design, write explicit steps and decision rules usually that a computer can identify
CT vs Coding
CT = the plan
Coding = the implementation

D. What Mastery Looks Like for ds4EEB
Break a messy problem into steps without prompting, or write instructions someone else could follow exactly, or ESPECIALLY catch ambiguity (“wait, what counts as 'done'?”)


In-Class Activity
5 min think-pair-share
How have they used CT in their lives without realizing it
When do they WISH they had applied CT as it would have made something easier in the long run
